
The Five Dreyfus Model Stages
=================================

1.Novices<br>
 >  have little or no previous experience in this skill area. By "experience" I mean specifically that performing this skill results in a change of thinking.
  As a conterexample, consider the case of the developer who claims ten years of experience, but in reality it was one year of experience repeated nine times.
  That doesn't count as `experience`.<br>
  `Novices need recipes`.<br>
  
2.Advanced Beginners<br>
 > can start to break away from the fixed rule set a little bit.They can try tasks on their own, but they still have difficulty troubleshooting.
 Although they can start formulating some overall principles ,there is no "big picture". They have no holistic understanding and really don't want it yet.
 
3.Competent<br>
 > practitioners can now develop conceptual model of the problem domain and work with those models effectively. They can troubledshoot problems ont heir own and
 begin to figure out how to solve novel problems--ones they haven't faced before. Their work is based more on deliberate planning and past experience. Without more
 experience, they will still have trouble trying to determine which details to focus on when problem soving.There isn't yet enough ablitiy for reflection and
 selfcorrection.
 
 4.Proficient<br>
 > They will seek out and want to understand the larger conceptual framework around this skill,they will be very frustrated by oversimplified information.
 They make a major breakthrough on the Dreyfus model: they can correct previous poor task preformance. They can reflect on how they've done and revise their approach to
 perform better the next time.
 
 5.Expert<br>
  >They are the ones who continually look for better of experience that they can tap into and apply in just the right context.
  Experts work from intuition, not from reason. <br>

Q: 知道了这个模型，有什么用处？如何有效的使用该模型改善学习、工作？<br>
A：作者提炼了几个要点：<br>
  1.　勇于承担责任（改变工作态度），将Advanced Beginners培养成Competent作为一个目标，为完成这个目标，需要好在环境中存在好的榜样，人们善于通过观察和模仿进行学习。<br>
  2.　在实践中保持技能。又提到了“优胜者不会帮扶失败者”理论，所以进一步提出为高技能开发人员提供合适的环境，那么如何提供这个环境？<br>
  >设置一个能够反映优秀程序员价值的薪酬等级和职业阶梯是实现这个目标的第一步。<br>
  
 怎么看这些都是针对一个公司（组织）而言的方法论，对于个人来讲怎么使得该模型落地并没有明确的答案。不过作者提到的理论对于程序员来说还是很有借鉴意义的：比如说“优胜者不会帮扶失败者”换句话说不要误入“拜大牛为师”的幻想中，[《不止代码》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1530517140411/Codelife.pdf)李云华老师说的句句都是肺腑之言，深以为然，放弃幻想，“打铁还需自身硬”。<br>
 
  作者又提到了大家耳熟能详的“十年成就专家”（一万小时）理论,一定要注意：<br>
  >而且需要辛勤工作，只是在某领域工作十年是不够的。你需要实践，根据著名认知科学家Dr.K.Anderson Ericsson的说法，积极的实践需要四个条件：<br>
   1.　需要一个明确定义的任务。<br>
   2.　任务需要有适当难度-有挑战性但可行。<br>
   3.　任务环境可以提供大量反馈，以便于你采取行动。<br>
   4.　提供重复犯错和纠正错误的机会。<br>
   
   仔细想想这些条件也不是那么容易得到，比如说我要学习高并发、分布式，那么1，2我觉得可以搞定，那么3，4如何来呢？<br>作者在第二章末尾又提出：
   >理解德雷福斯模型和技能获取本身也是一项技能，要根据该模型的具体情况，来学习如何学习。
   
  　那么如何理解“根据该模型的具体情况”这句话呢？从本章节的“实践单元”可以体会到作者的本意:<br>
  >1. 自我评价。你认为你在工作中使用的主要技能处于德雷福斯模型的什么位置。列举出你目前的技能水平对你产生了哪些影响。<br>
   2. 辨别哪些技能是新手因该具备的，哪些是高级初学者应该具备的等等。<br>
   3. 对于每项技能，判断你需要做什么才能提高一个级别。在阅读以后章节的时候谨记这些例子。<br>
   
  通过阐述模型使读者了解一个评价技能水平的标准，该标准具备很强的指导意义。读者通过该模型评价自己现阶段究竟处于哪个阶段，通往下一阶段又需要什么样的技能？那知道了不足，又如何提高呢？作者进而又提出“学习如何学习”的命题，进而过渡到第三章节：认识你的大脑。<br>
  
  认识你的大脑
  =================================
  该章节中，通过类比，大脑工作机制分为L、R型。L工作时记忆的总线被占用，R型产生的记忆是无法在此时提取，反之亦然。R型记忆非语言可以描述的，比如图像、情感和整体经验都是R型的。记忆需要进行定时刷新，否则就会忘记。结合记忆曲线进行学习会取得更好的效果。因为L型很显而易见，故作者写到：<br>
  >我们需要更多的使用R型，因为R型能够提供直觉，这是成为一名专家所迫切需要的。。。R型的类比和整体思考的方式对软件架构和设计非常有价值，好的设计就是由这些组成。。。。面对复杂的设计问题或者难以修改的bug，优秀的程序员常有冲动去编码和重构，由此可以从中学习。这就是R型的综合，而不是L型的分析。
  但是光有R型也是不成的，必须两者进行结合。本章节作者旁征博引的向读者灌输：R型尚未充分使用。进而抛出问题，如何进行R型思维？以及如何更好的协调R型与L型的协作呢？
  
  
  利用右脑
  =================================
  作者开篇提出：要投入更多的脑物质去解决问题和发挥创造力，最简便的方式便是激活更多的神经通路。比如：<br>
  1 使用乐高积木做面向对象的设计或者CRC卡片。<br>
  2 绘画。不是简单的符号抽象，二十真正的洞察真实的事物。<br>
 
  作者提到“如果你还没有全局的概念就试图记忆细节，那么学习就会陷入僵局”，“不要太着急。解决问题时候，学会轻松面对不确定的事情。进行创造时，坦然面对荒谬和不切实际的东西。学习过程中，不要太迫于学会和记忆，首先只是适应它。试着先理解其意义，掌握主旨思想”。列举这些例子旨在更好的说明利用R型来认识深林，通过L型认识数木。作者还列举了大量能够切入R型的方式方法。比如利用图像流，隐喻，晨写技术等等。就试着这三种即可。<br>
  
  
  主动学习
  =================================
  “大脑不是一个用于填充的容器，而是一束需要点燃的火焰”普卢塔赫（希腊哲学家）如是说。如果没有任何初级阶段的“填充”，那么“燃烧”的是什么呢？作者又说道“单纯密集，脱离情景的课堂教育最多只能给你正确的方向。你需要持续的目标，需要反馈以了解你的进展，需要更加主动全面的学习”，我觉得“把一壶水烧开”需要“密集”的训练，特别是工作之后只有零散空余时间，不能再采取学生时代那种学习策略，要学得东西非常多，那么就需要排列顺序，集中三五个月，甚至一年时间来突破某个任务才是正确的方法。学习效率高低也是一个关键因素，如何提高学习效率呢？SMART大法好：S-specific,M-measurable,A-achievable,R-relevant,T-time-boxed，核心要义是避免制定泛泛而谈的目标，目标制定的越具体，越接地气，实现的成功性就越大。举个列子：只是说“我要学会Java”，这是远远不够的。应该把事情具体化，例如“我想要用Java写一个简易的web服务器,这个服务器有这点。。。那点。。。”这个就很具体了。还要注意大法中的最后一个T,作者告诫道：<br>
  >这可能是目标最重要的一个特性。这意味着你也需要设定一个最后期限。没有期限，目标就会逐步衰退，永远被被每天更紧急的事情排挤。这样它永远不会实现。。。我们大多数人常常陷入一种默认的学习日程表：等到有空了在花时间学习一门新语言或者新函数库。不幸的是，把你的学习活动流放到“空闲时间”去，这就等同于失败。
    
  扎心了老铁，做到这一点可不容易，我觉得必须要计划写出来，打印出来，贴到床头，每日三省吾身，把重要的事情放在自己的时间线里面去。野心勃勃的目标制定好了？接下来该怎么办呢？是要立马进行目标分解制定计划吗？“知识投资组合”理论告诉你先憋慌:<br>
  >像管理你的金融投资一样小心的管理你的知识投资。
  
  重新审视下目标吧:<br>
   1. 是否是多样化的？<br>
   >学习一门流行的技术如.NET（Java)风险非常低--许多领域的程序员都在用它。。。但是这也意味着投资回报率非常低---有很多领域的程序员在用它，所以就业岗位会有大量竞争。你学习它并不会变得很特别。
    对于这点持保留意见，如果一门语言根本没人用或者用的人非常少（Lisp，hashkell)，市面上很少有就业机会，那么学这些又能怎么样呢？用的人少也意味着“坑”多。对于现在而言，人工智能或者区块链是不是当年的Java?以后会越来越多的工作机会呢？<br>
    
   2.是否是主动投资而不是被动投资？<br>
    >你不能只是守着你的资产。。。从你开始投资之后，世界上有什么关键技术或者重要人物发生改变吗？
    这个问提简直是为区块链而提的。<br>
    3.定期投资<br>
    >在金融领域，你需要采用成本平均分。这意味着你定期购买股票，有时你会付出很多，有时候你会收益很多，但是从长期来看，这些差异互相抵消，一般最后你都会获得较好的回报。。。并非每期学习都同样富有成效，但是只要定期安排学习，长期来看一定会成功。如果你一直等待空闲时间或者等待灵感的出现，那么它永远都不会发生。
    
    制定好了合理的目标，该撸起袖子干了，等等，你知道自己的原生学习类型了吗？视觉、听觉、还是触觉对你的学习影响效率有比较大的影响呢？你的性格是怎么样的呢？MBTI测试可以告诉大家，你的默认设置是多少。但这些智力和性格的分类只是表示一种可能型，不是硬性的规定和判决。“Type is not destiny"。<br>
    
  
  学习方法论
  ========================
   >“此时此刻，你正在阅读本书。一生中，你所读的书可能比听的讲座多很多。但是相比于任何由经验式的学习方法，阅读时一种效率最低的学习方法。。。对于你想要训练或者教育的大脑和身体，它们当中有很多部分不是处理语言的。大脑处理语言的部分很小。。。我们都是天生的模仿者，最佳且最有效的方式时观察和模仿别人。。。”，这点我很困惑，可能相较于管理或者高效能之类的技能类经验，通过观察和模仿，的确能够学习到别人。可是自然学科的知识又如何能观察和模仿别人呢？总归是从书本上的来的啊。虽然阅读被说成低效，可还是有方法来提高学习的效率。<br>
   
   SQ3R主动阅读技巧<br>
   ===============================
   SURVEY:扫描目录和每章总结，得出总体看法。<br>
   QUESTION:记录所有问题。<br>
   READ:阅读全部内容。<br>
   RECITE:总结，做笔记，用自己的话来描述。<br>
   REVIEW:回顾，重读，扩展笔记，与同事讨论。<br>
   
   测试驱动学习法
   ==================================
   一个悲伤的事实是：重复阅读同样的材料或者重复复习相同的笔记，不会有助于你记住材料。尝试测试吧。当测试自己时，可以利用间隔效用。间隔测试时间可以显著增强记忆。例如，可以按照2-2-2-6模式设定测试时间表：在两个小时、两天、两周和六个月之后重新测试。（SuperMemo 软件帮助我们管理测试时间提醒）。
   
   

   
    
    
    
